"""Лабораторная работа № 2. Работа с Массивами и матрицами с использованием библиотек NumPy."""

import numpy as np
import math as ma
"""Цель лабораторной работы - научиться выполнять простые математические действия над матрицами и массивами с использование библиотеки NumPy. 

Задачи лабораторной работы: 

1.Научиться создавать одномерные, двумерные и многомерные массивы  с помощью NumPy.
2.Научиться работать с основными функция библиотеки NumPy. 
3.Усвоить принципы Индексации, сечения и итерации массивов в NumPy.

Библиотека NumPy это пакет для научного вычисления на языке программирования Python. Это библиотека Python, 
которая предоставляет объект многомерного массива, различные производные объекты (такие как массивы и матрицы) 
и набор процедур для быстрых операций с массивами, включая математические, логические, манипуляции с формами, сортировку, 
выбор, ввод-вывод, дискретные преобразования Фурье, базовая линейная алгебра, основные статистические операции, случайное моделирование и многое другое.

В основе этой библиотеки лежит ndarray объект. Это n-мерный массив однородных типов данных.
Особенности массивов NumPy:

●Массивы NumPy имеют фиксированный размер при создании, в отличие от списков Python (которые могут расти динамически). 
Изменение размера ndarray создаст новый массив и удалит оригинал.

●Все элементы в массиве NumPy должны иметь один и тот же тип данных и, следовательно, будут иметь одинаковый размер в памяти. 
Исключение: можно иметь массивы (Python, включая NumPy) объектов, что позволяет создавать массивы элементов разного размера.

●Массивы NumPy упрощают сложные математические и другие типы операций с большим количеством данных. 
Обычно такие операции выполняются более эффективно и с меньшим количеством кода, чем это возможно при использовании встроенных последовательностей Python.

Растущее множество научных и математических пакетов на основе Python используют массивы NumPy; 
хотя они обычно поддерживают ввод последовательности Python, они преобразуют такой ввод в массивы NumPy перед обработкой и часто выводят массивы NumPy. 
Другими словами, чтобы эффективно использовать большую часть (возможно, даже большую часть) современного научного / математического программного обеспечения 
на основе Python, недостаточно просто знать, как использовать встроенные типы последовательностей Python - также необходимо знать, как использовать массивы NumPy."""

"""Ход работы:"""

'''а) создадим массив NumPy из списка с помощью функции array().
Эта функция трансформирует вложенные последовательности в
многомерные массивы.'''

import numpy as np
x = [1, 2, 3]
my_array = np.array(x)
print('It is my list', x, 'with type of', type(x))
print('It is my array', my_array, 'with type of', type(my_array))

'''б) создадим массив из кортежа с помощью функции array(). Эта
функция трансформирует вложенные последовательности в
многомерные массивы.'''

y = (1, 2, 3)
my_array_2 = np.array(y)
print('It is my list', y, 'with type of', type(y))
print('It is my array', my_array_2, 'with type of', type(my_array_2))

'''в) Попробуем создать массив из последовательности чисел'''

numbers_array = np.array([1, 2, 3, 4])
'''Если записать numbers_array = np.array(1, 2 , 3, 4) - получим ошибку '''
print('It is my array', numbers_array, 'with type of', type(numbers_array))

'''г) Создать массив с различными типами данных'''

my_array_float_float = np.array([1, 2, 3, 4], dtype=np.float64)
my_array_float_float_64 = np.array([1, 2, 3, 4], dtype=np.float64)
my_array_float_float_complex_64 = np.array([1, 2, 3, 4], dtype=np.complex64)
my_array_float_float_complex = np.array([1, 2, 3, 4], dtype=np.complex64)
#my_array_float_float_128 = np.array([1, 2, 3, 4], dtype=np.float128)
my_array_float_float_64_2 = np.array([1, 2, 3, 4], dtype=np.float64)
my_array_float_str = np.array([1, 2, 3, 4], dtype='str')

print(my_array_float_str)

'''д) Создадим двухмерную матрицу, используя функцию array().
Создадим последовательность чисел используя функции arange и
linspace. arange(start, stop, step) - функция создает
последовательность чисел от числа start до значения stop не включая
его, с шагом step. По-умолчанию step=1, а start=0.
linspace(start, stop, step_numbers) - функция создает последовательность
чисел от числа start до значения stop, включая его, с количеством шагов
равным step_numbers'''

arrange_numbers_1 = np.arange(10)
arrange_numbers_2 = np.arange(10, 30, 5)

'''Вообще, при использовании arange() с аргументами типа float, сложно
быть уверенным в том, сколько элементов будет получено (из-за
ограничения точности чисел с плавающей запятой). Поэтому, в таких
случаях обычно лучше использовать функцию linspace(), которая вместо
шага в качестве одного из аргументов принимает число, равное
количеству нужных элементов:'''

linspace_numbers_1 = np.linspace(10, 20)
linspace_numbers_2 = np.linspace(10, 20, 9)
linspace_numbers_3 = np.linspace(10, 20, 9, endpoint=False)

print(arrange_numbers_1)
print(arrange_numbers_2)
print(linspace_numbers_1)
print(linspace_numbers_2)

matrix_2D = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(matrix_2D)

'''е) Создадим двухмерную матрицу, используя функцию np.zeros([Nx,
Ny]). Этот функция создает нулевую матрицу размером Nx на Ny'''

nx = 3
ny = 5
zero_matrix = np.zeros([nx, ny], dtype = int)
print(zero_matrix)

'''ж) Создадим двухмерную матрицу, используя функцию np.eye([N]).
Этот функция создает квадратную матрицу размером N, заполненную
единицами по диагонали.'''

one_matrix = np.eye(5)
print(one_matrix)


'''2. Индексация, сечение и итерация массивов
Индексация в Python осуществляется с 0 элемента. Выведем элементы
матрицы со 2-ого по 5 ый.'''

matrix_1 = np.array([1, 2, 3, 4, 5, 6])
print(matrix_1[2:5])

'''Выведем на экран элементы массива с нулевого индекса по 100-ый, и
каждые 5 элемент.'''

range_100 = np.arange(100)
print(range_100[:100:5])

'''Выведем на экран элементы массива с 20-ого индекса по 60-ый, и каждые
5 элемент'''

print(range_100[20:60:5])

'''Выведем последний элемент'''

print(range_100[-1])

'''Выведем обратную последовательность'''

print(range_100[::-1])

'''Напечатаем строки и элементы матрицы'''

matrix_2D_2 = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
print(matrix_2D_2)

for row in matrix_2D_2:
    print('It is a row', row)
    for element in row:
        print('It is element', element)
    for element in matrix_2D_2.flat:
        print(element)

print(matrix_2D_2.reshape(1,9))


a12 = np.array([1, 2, 3])
print(a12)

