'''Лабораторная работа No 3. Работа с функциями в NumPy. Базовые
операции NumPy.
Цель лабораторной работы - освоить основные методы библиотеки
NumPy для обработки массивов чисел.'''

'''1.1. Загружаем библиотеку numPy в код программы'''
import numpy as np

'''2.2. Создадим три трехмерных вектора [0, 0, 0], [1,  1, 1], [1, 2, 3]. 
Один из самых простых способов использовать встроенные 
методы класса numPy  - это zeros() для нулевой матрицы, ones() для единичной.'''

vector_zero = np.zeros(3)
vector_one = np.ones(3)
vector = np.array([1, 2, 3])

'''2.3. Выполним сложение этих векторов используя оператор “+”. 
Получившиеся результаты выведем на экран. '''

sum1 = vector_zero + vector_one
sum2 = vector_one + vector
print(sum1, sum2)

'''2.4. Выполним вычитание этих векторов используя оператор “-”. 
Получившиеся результаты выведем на экран. '''

diff1 = vector_zero - vector_one
diff2 =vector_one - vector
print(diff1, diff2)

'''2.5. Выполним умножение этих векторов используя оператор “*”. 
Получившиеся результаты выведем на экран. '''

mult1 = vector_zero * vector_one
mult2 = vector_one * vector
print(mult1, mult2)

'''2.6. Выполним деление этих векторов используя оператор “/”. 
Получившиеся результаты выведем на экран. '''

div1 = vector_zero / vector_one
div2 = vector_one / vector
print(div1, div2)

'''2.7. Провести эти же математические над типом данных список со 
значениями как у векторов выше. Полученные результаты вывести на экран 
и сравнить с результатами полученными с помощью библиотеки numPy. '''

list_zero = [0, 0, 0]
list_one = [1, 1, 1]
list_1 = [1, 2, 3]
sum1_list = list_zero + list_one
sum2_list = list_one + list_1
print(sum1_list, sum2_list)
#mult1_list = list_zero * list_one
#mult2_list = list_one * list_1
#print(mult1_list, mult2_list)
#dif1_list = list_zero - list_one
#dif2_list = list_one - list_1
#print(dif1_list, dif2_list)

'''3. Математические операции над векторами и матрицами в некоторых случаях отличаются. В этой части лабораторной работы ознакомимся над основными математическими операциями над матрицами. 
3.1. Создадим квадратную матрицу размером три заполненную единицами и такую же матрицу со значениями элементов от 1 до 10. 
'''

matrix1 = np.ones([3, 3])
matrix2 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

'''3.2. Выполним сложение этих матриц, используя оператор “+”. 
Получившиеся результаты выведем на экран. '''

print(matrix1 + matrix2)

'''3.3. Выполним вычитание этих матриц, используя оператор “-”. 
Получившиеся результаты выведем на экран. '''

print(matrix1 - matrix2)

'''3.4. Выполним поэлементное умножение этих матриц, используя оператор “*”. 
Получившиеся результаты выведем на экран. '''

print(matrix1 * matrix2)

'''3.5. Выполним поэлементное деление этих матриц, используя оператор “/”. 
Получившиеся результаты выведем на экран. '''

print(matrix1 / matrix2)

'''3.6. Выполним поэлементное возведение в степень элементов матриц, используя оператор “**”. 
Получившиеся результаты выведем на экран. '''

print(matrix1 ** matrix2)

'''4. Процедуры скалярного и векторного умножения также доступны для реализации с помощью этой библиотеки. 
Для этого необходимо вызвать методы класса numPy. '''

'''4.1. Произвести скалярное произведение вектора и матрицы '''

print(np.dot(vector, matrix1)) # Скалярное произведение

'''4.2. Произвести скалярное произведение матрицы на матрицу. '''

print(np.dot(matrix1, matrix2))

'''4.3. Произвести векторное умножение вектора на матрицу'''

print(np.cross(vector, matrix2))

'''4.4.  Произвести векторное умножение матрицы на матрицу'''

print(np.cross(matrix1, matrix2))

'''5. Помимо математический манипуляций между разными объектами(переменными), 
встречаются задачи изменение значений или поиск по определенному алгоритму 
значений элементов самого массива. В библиотеке numPy встроено много функций 
для манипуляций над элементами матриц. Рассмотрим ряд из них. '''

'''5.1. Найти максимальное, минимальное значения вектора и матрицы 
с помощью методов max() и min(). '''

print('Minimum value of vector ', vector.min())
print('Maximum value of vector ', vector.max())
print('Maximum value of matrix1 ', matrix1.max())
print('Minimum value of matrix1 ', matrix1.min())

'''5.2. Найдем сумму всех элементов вектора и матрицы. '''

print('Sum value of matrix1 ', matrix1.sum())
print('Sum value of vector ', vector.sum())

'''5.3. Найти максимальное, минимальное и сумму всех значение в каждой строке матрицы. 
Для этого необходимо указать ось массива вдоль которого необходимо проводить эту операцию. 
Эта операция выполняется  с помощью присваивания переменной axis значения 0 для строк, 1 
для столбцов при вызове метода операции. '''

print('Maximum value of matrix2 ', matrix2.max(axis=0))
print('Minimum value of matrix2 ', matrix2.min(axis=0))
print('Sum value of matrix1 ', matrix1.sum(axis=0))

'''5.4. Найти максимальное, минимальное и сумму всех значение в каждом столбце матрицы. 
Для этого необходимо указать ось массива вдоль которого необходимо проводить эту операцию. 
Эта операция выполняется  с помощью присваивания переменной axis значения 0 для строк, 
1 для столбцов при вызове метода операции. '''

print('Maximum value of matrix1 ', matrix1.max(axis=1))
print('Minimum value of matrix1 ', matrix1.min(axis=1))
print('Sum value of matrix1 ', matrix1.sum(axis=1))

'''5.5. Произвести умножение всех элементов поочередно можно с помощью функции prod(). 
Выполнить эту операцию для произвольной последовательности чисел. '''

seq1 = np.array([0, 1, 2, 3, 4, 5])
seq2 = np.array([3, 5, 7, 9, 11, 13])

prod_seq1 = np.prod(seq1)
prod_seq2 = np.prod(seq2)
print(prod_seq1, prod_seq2)

'''5.6. Произвести возведение всех элементов последовательности в степень два и степень изменяющуюся с номером элемента. 
Для этого использовать метод power(). '''

power_seq1 = np.power(seq1, 2)
power_seq2 = np.power(seq2, seq1)
print(power_seq1, power_seq2)

'''5.7. Значения элементов массива можно изменять с помощью следующих функций: 
●	sqrt(x) - вычислить корень элементов массива x. 
●	log(x) - вычислить натуральный логарифм элементов массива x. 
●	log2(x) - вычислить двоичный логарифм элементов массива x. 
●	logn(n, x) - вычислить логарифм элементов массива x по основанию n. 
●	log10(x) - вычислить десятичный логарифм элементов массива x.
●	power(x, p) - возвести все элементы массива x в степень p. 

Выполнить ряд математических операций над элементами матриц, используя эти 
методы класса. Реализовать следующее выражение 

S_sigma = 1/n * sum (1,n) -> (s1+s2)^(1/2)
'''

sum_seq = 1/(seq1.size) * np.sum(np.sqrt(seq1 + seq2))
print('!!!', sum_seq)

'''6. Преобразование матриц является важным элементом линейной алгебры. 
Поэтому важно рассмотреть возможности реализации этих операций с помощью numPy.'''

'''6.1. Выполним самую популярную операцию - это трансформацию матрицы. 
Значение трансформируемой матицы доступно в атрибутах матрицы через ‘.T’. 
Выполним трансформацию вектора и матрицы, и выведем результат на экран.'''

print(vector)
print(vector.T)
print(matrix2)
print(matrix2.T)

'''6.2. Изменение размеров массива возможно выполнить с помощью метода reshape(). 
В аргументах метода указывается размер нового массива, причем новый размер 
должен быть кратен старому. Создадим диапазон чисел от от 0 до 10 
и трансформируем его в матрицу 2 на 5, 5 на 2 и 10 на 1.'''

data = np.array(range(10))
print(data)
print(data.reshape(2, 5))
print(data)
print(data.reshape(5, 2))
print(data.reshape(10, 1))

'''6.3. Манипуляция над размерами матрицы очень важен
 для решения ряда математических задач. 
Рассмотрим как получить значения диагонали матрицы с помощью метода diagonal() '''

a = np.array([0, 1, 2])
b = np.array([3, 4, 5])

diagonal = np.diagonal(matrix2)
print('It is diagonal ', diagonal)

'''6.4. Важной операция является разделение массива на равные отдельные массивы. 
За это отвечает метод np.array_split(x, 4). 
Попробовать разделить любой массив на несколько массивов. '''

x = np.arange(9)
print(np.array_split(x, 4))

'''6.5. Присоединение новых элементов в столбцам или строкам осущессвтляется методами hstack() и vstack(). 
Реализовать эти методы над произвольными матрицами и понять принцип их работ'''

a = np.array((1, 2, 3))
b = np.array((4, 5, 6))
np.hstack((a, b))
np.hstack((a, b))

a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

np.stack((a, b), axis=-1)
np.stack((a,b), axis=1)

"""Дополнительное задание - перемножить матрицы"""

'''число столбцов матрицы1 должно быть равно числу строк матрицы 2'''
'''Скалярное произведение массивов'''

matrix1 = [[1, 1], [2, 2], [3, 3]]
matrix2 = [[2, 2, 2], [4, 4, 4]]
matrix3 = [] #Итоговая матрица будет иметь размер = число столбцов 1-й матрицы * число строк 2-й матрицы
if len(matrix1[1]) == len(matrix2): #Проверка условия возможности умножить матрицы
    for i in range(len(matrix1)): #Проходимся по строкам (равно длине строки во 2-й) 1-й матрицы и формирование первой строки итоговой матрицы
        prom = 0
        pr = []
        for k in range(len(matrix2[0])): #Проход по строке 2-й матрцы. Нужно для формирования столбцов ответа т.к. их количество равно длине строки (числк столбцов) 2-й матрицы
            for j in range(len(matrix2)): #Вычисление элемента итоговой матрицы. В данном случае - 2 раза
                prom += int(matrix1[i][j]) * int(matrix2[j][k])
            pr.append(prom)
            prom = 0
        matrix3.append(pr)
print(matrix3)







